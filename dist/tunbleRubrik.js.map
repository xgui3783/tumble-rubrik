{"version":3,"sources":["util/util.js","tunbleRubrik.js"],"names":["x","Set","y","z","determineAxis","letter","find","sth","has","validateSpace","spaceString","length","Error","set","split","map","l","toUpperCase","reduce","acc","curr","add","undefined","reorderCoordBySpace","input","coordSpace","arr","findIndex","tuple","v","cvtSpace","fromCoordSpace","fromDims","dims","toCoordSpace","idx","cvtRealVoxel","voxelDims","fromRealFlag","realFlag","toRealFlag","out","presetMap","Map","Space","presetSpaceName","get","reorderFn","reorderedFromCoordSpace","join","reorderedDims","cvtSpaceFn","reorderedVoxelDim","getVoxelReal"],"mappings":"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","file":"tunbleRubrik.js","sourceRoot":"..","sourcesContent":["const x = new Set(['L', 'R']),\n  y = new Set(['A', 'P']),\n  z = new Set(['S', 'I'])\n\nconst determineAxis = letter => [x, y, z].find(sth => sth.has(letter))\n\nconst validateSpace = spaceString => {\n  if(spaceString.length !== 3) throw new Error('space needs to be 3 letters long')\n  const set = spaceString.split('')\n    .map(l => l.toUpperCase())\n    .reduce((acc, curr) => new Set(acc).add(determineAxis(curr)), new Set())\n  if(set.length < 3 || set.has(undefined)) throw new Error('set is ill defined')\n  return spaceString\n}\n\n/**\n * \n * @param {Space} fromSpace\n * @param {Space} toSpace\n * @Output {Function} coord => reorderedCoord \n * n.b. only reorders. \n * So it wil turn RAS to ARS etc, but will not convert RAS to ALS\n */\nconst reorderCoordBySpace = ({coordSpace: input}, {coordSpace: target}) => {\n  const arr = target.split('')\n    .map(letter => \n      input.split('').findIndex(l => determineAxis(l) === determineAxis(letter))\n    )\n  return (tuple) => [0, 1, 2].map(v => tuple[arr[v]])\n}\n\n/**\n * \n * @param {Object} fromSpace \n * @param {Object} toSpace \n * n.b. only converts values. Strict equality check, if fails, assumes opposite.\n * e.g. RAS, ARS will result in output of LPS\n * use @function {reorderCoordBySpace} first to convert order\n */\nconst cvtSpace = ({ coordSpace: fromCoordSpace, dims:fromDims }, { coordSpace: toCoordSpace }) => tuple  => tuple.map((v, idx) => \n  fromCoordSpace[idx] === toCoordSpace[idx]\n    ? v\n    : fromDims[idx] - v)\n\nconst cvtRealVoxel = ({ voxelDims, realFlag: fromRealFlag }, { realFlag: toRealFlag }) => tuple => tuple.map((v, idx) => {\n  let out = v\n\n  // if source is voxel, convert to real\n  if (!fromRealFlag) out *= voxelDims[idx]\n  if (!toRealFlag) out /= voxelDims[idx]\n  return out\n})\n\nexport {\n  validateSpace,\n  reorderCoordBySpace,\n  cvtSpace,\n  cvtRealVoxel\n}","import { reorderCoordBySpace, cvtSpace, cvtRealVoxel } from './util/util'\n\nconst presetMap = new Map([\n  ['allenCCFv3_2017_10', {\n    realFlag: false,\n    coordSpace: 'PIR',\n    voxelDims: [0.01, 0.01, 0.01],\n    dims: [1320, 800, 1140]\n  }],\n  ['WHSv3', {\n    realFlag: false,\n    coordSpace: 'RAS',\n    voxelDims: [0.0390625, 0.0390625, 0.0390625],\n    dims: [512, 1024, 512]\n  }]\n])\n\n/**\n * voxel dimension in mm/voxel\n * dims unit depends on realFlag\n * if realFlag is true, then dims is in [mm, mm, mm]\n * else, dims is in [voxel, voxel, voxel]\n */\nclass Space{\n  constructor({ presetSpaceName, realFlag, coordSpace, voxelDims, dims } = {}){\n    if (presetSpaceName && presetMap.get(presetSpaceName)) {\n      const {\n        realFlag,\n        coordSpace,\n        voxelDims,\n        dims\n      } = presetMap.get(presetSpaceName)\n      this.realFlag = realFlag,\n      this.coordSpace = coordSpace\n      this.voxelDims = voxelDims\n      this.dims = dims\n      return\n    }\n\n    this.realFlag = realFlag,\n    this.coordSpace = coordSpace\n    this.voxelDims = voxelDims\n    this.dims = dims\n  }\n\n  getTransformCoordFn({ realFlag = this.realFlag, coordSpace = this.coordSpace } = {}){\n    \n    const reorderFn = reorderCoordBySpace(this, { coordSpace })\n    const reorderedFromCoordSpace = reorderFn(this.coordSpace.split('')).join('')\n    const reorderedDims = reorderFn(this.dims)\n\n    const cvtSpaceFn = cvtSpace({coordSpace: reorderedFromCoordSpace, dims: reorderedDims}, { coordSpace })\n    const reorderedVoxelDim = reorderFn(this.voxelDims)\n\n    const getVoxelReal = cvtRealVoxel({ voxelDims: reorderedVoxelDim ,realFlag: this.realFlag }, { realFlag })\n\n    return tuple => getVoxelReal(cvtSpaceFn(reorderFn(tuple)))\n  }\n}\n\nexport {\n  Space,\n  presetMap\n}"]}